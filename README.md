## Реализация двоичного дерева поиска на JavaScript

### Описание

![bst](https://user-images.githubusercontent.com/37180024/96990365-b046ac80-152f-11eb-8c06-4c836998fb52.png)

Узел в двоичном дереве (или как его еще называют бинарном) имеет не более двух дочерних элементов: левого и правого элемента. 
Это определение позволяет вам писать алгоритмы для более эффективной вставки, поиска и удаления узлов. 

![bst example](https://user-images.githubusercontent.com/37180024/96990580-fa2f9280-152f-11eb-9f85-6fa6436aab4d.png)

Двоичное дерево поиска (**binary search tree — BST**) — это тоже двоичное дерево. 

Основное отличие состоит в том, что BST позволяет хранить отсортированные узлы с меньшим значением слева и узлы с большим значением справа.

#### Обход BST

**Обход дерева (Traverse)** — это процесс посещения всех узлов дерева и выполнения операции на каждом узле. 

Существует три общих подхода: 
* **Прямой (in-order)**;
* **Симметричный или поперечный (pre-order);**
* **В обратном порядке (post-order).**

##### Прямой обход

При прямом обходе будут посещаться все узлы в порядке возрастания, начиная с указанного узла (хотя это и необязательно), и выполнять заданную функцию обратного вызова callback (также необязательно).

![in-order traverse](https://user-images.githubusercontent.com/37180024/97105062-7d382080-16c9-11eb-9e3f-498eaa4cf894.png)

##### Симметричный обход

При симметричном обходе посещаются каждый узел до его потомков. 

![pre-order traverse](https://user-images.githubusercontent.com/37180024/97105193-3991e680-16ca-11eb-8b75-908d4d8b2590.png) 

##### Обход в обратном порядке

При обходе в обратном порядке посещаются узлы после посещения его потомков.

![post-order traverse](https://user-images.githubusercontent.com/37180024/97105248-7f4eaf00-16ca-11eb-9b65-f2b7224a21ab.png)

#### Удаление узла из BST

Метод удаления является наиболее сложным. Его сложность обусловлена различными сценариями, которые нам нужны.

В начале мы ищем соответствующий узел, который нужно удалить, а потом есть три сценария, которые мы рассмотрим более подробно ниже.

##### Удаление крайнего узла (leaf node)

Первый сценарий включает в себя крайний узел (**leaf node**), то есть у которого нет левого или правого дочернего элемента. В этом случае нам нужно будет удалить узел, присвоив ему значение `null`. Однако не стоит забывать, что мы также должны позаботиться о ссылках из родительского узла.

![delete leaf node](https://user-images.githubusercontent.com/37180024/97105351-13207b00-16cb-11eb-84a6-6212ac846fb2.png)

##### Удаление узла с одним потомком

Второй сценарий включает в себя узел, который имеет левый или правый дочерний узел. Как вы можете видеть на диаграмме ниже, нам нужно пропустить соответствующий узел и назначить родительский указатель на дочерний узел:

![delete node that has one child](https://user-images.githubusercontent.com/37180024/97105390-64306f00-16cb-11eb-9d4e-2695e38053c9.png)

##### Удаление узла с двумя потомками

Третий и последний сценарий включает в себя узел с двумя дочерними элементами. Чтобы удалить такой узел, нужно выполнить следующие действия:

1. Как только вы найдете узел, который нужно удалить, найдите минимальный узел из его правого края поддерева (см. заштрихованную область на диаграмме ниже).
2. Далее вы можете обновить значение узла ключом минимального узла из его правого поддерева. Этим действием вы заменяете ключ узла, что означает, что он будет удален.
3. Теперь у вас есть два узла в дереве с одним и тем же ключом, что не правильно. Таким образом, нужно удалить минимальный узел из правого поддерева, поскольку вы переместили его на место удаленного узла.
4. Наконец, нужно вернуть обновленную ссылку на узел его родителю.

![delete node that has two children](https://user-images.githubusercontent.com/37180024/97105460-ddc85d00-16cb-11eb-9982-0e212ad1a409.png)
